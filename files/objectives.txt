Objective:

Create a CPU process scheduler that assigns processes from an input file to 2 CPUs based on the specified criteria.
Perform resource checks (RAM, CPU) and assign processes according to their priority.
Ensure CPU-1 handles processes with priority 0 using the First-Come, First-Serve (FCFS) algorithm.
Assign other priorities to CPU-2 using different algorithms (SJF, Round Robin with quantum times).
Given these requirements, here's a roadmap to structure your project:

Process Structure:
	Define a structure ProcessInfo that holds the attributes of a process like process_number, arrival_time, priority, burst_time, ram, and cpu_rate.
Input Parsing:
	Write a function to parse the input file and populate a list of ProcessInfo structures.
Scheduler Structure:
	Create a structure for CPU-1 and CPU-2, each with their own respective queues.
	CPU-1's queue will use FCFS, while CPU-2 will contain three queues for SJF, RR with 8s quantum, and RR with 16s quantum.
Resource Check:
	Write a function to check if there's sufficient RAM and CPU resources to assign a process to a CPU.
	Implement the logic for maintaining 512 MB reserved for CPU-1 processes.
Scheduler Algorithms:
	Implement the FCFS algorithm for CPU-1.
	Implement the SJF algorithm for high-priority user processes.
	Implement the Round Robin algorithm for medium-priority (quantum time of 8s) and low-priority user processes (quantum time of 16s).
Dispatcher Function:
	Write a function that iterates through the list of processes and assigns them to the appropriate CPU based on their priority and resource constraints.
	This function should also account for processes that arrive at different times, ensuring that the processes are dispatched accordingly.
Output Handling:
	Write output to a file output.txt as processes are assigned, executed, completed, and re-queued (for RR).
	Include detailed messages about each action taken, as specified in your example output.
Completion Check:
	Ensure the program runs until all processes from the input file are completed.
	At the end of the execution, output the status of the queues for each CPU.
Testing and Validation:
	Ensure the program handles various cases, including differing arrival times, priorities, and resource constraints.
	Validate against the sample input and expected output to ensure correctness.